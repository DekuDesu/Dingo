@using Dingo.Data.UserInfo

@inject NavigationManager NavManager
@inject ILogger<ChangeUsername> logger

@inject IFriendHandler friendHandler
@inject IFriendListHandler friendListHandler
@inject IDisplayNameHandler displayNameHander
@inject IValidator<DisplayNameModel> searchValidator

@using DingoAuthentication.Encryption

@inject IEncryptedClientStateHandler encryptionStateHandler
@inject IEncryptionClient<EncryptedDataModel> encryptionClient
@inject IKeyAndBundleHandler<KeyBundleModel> bundleHandler


<EditForm Context="User" @bind-model="displayName" OnValidSubmit="@Submit">
    <div class="row">
        <h2>Add Friend</h2>
    </div>
    <div class="row">
        <div class="row">
            <InputText class="form-control my-2" @bind-Value=@displayName.DisplayName />
        </div>
        <div class="row">
            @if (SearchTermValidationFailures is not null)
            {
                @foreach (var item in SearchTermValidationFailures)
                {
                    <p class="alert-warning rounded border">@item.ErrorMessage</p>
                }
            }
        </div>
        <div class="row col-6">
            <button type="submit" class=@ButtonClass>
                <span class=@CheckClass role="status" aria-hidden="true" style=@CheckStyle></span>
                <span class="spinner-border spinner-border-sm" role="status" aria-hidden="true" style=@SpinnerStyle></span>
                @ButtonText
            </button>
        </div>
    </div>
</EditForm>

@code
{

    [Parameter]
    public string Id { get; set; } = null;

    // make sure we get the display name
    [CascadingParameter]
    protected Task<AuthenticationState> AuthStat { get; set; }

    private string SpinnerStyle = "display: none";
    private string ButtonText = "Search";
    private string ButtonClass = "btn btn-primary";
    private string CheckStyle = "display: none";
    private string CheckClass = "oi oi-check";

    private enum ButtonState
    {
        normal,
        completed,
        failed
    }

    private DisplayNameModel displayName = new();

    private List<FluentValidation.Results.ValidationFailure> SearchTermValidationFailures;

    protected override async Task OnInitializedAsync()
    {
        await base.OnInitializedAsync();

        logger.LogInformation("Initialized Component {ComponentName} Params: {Param1}:{Param1Value}", nameof(AddFriend), nameof(Id), Id);
    }

    private void UpdateButton(string text, ButtonState state = ButtonState.normal, bool spinner = false)
    {
        SpinnerStyle = spinner ? "" : "display: none;";
        ButtonText = text ?? "Change";
        ButtonClass = state switch
        {
            ButtonState.failed => "btn btn-danger",
            ButtonState.completed => "btn btn-success",
            _ => "btn btn-primary"
        };
        CheckStyle = state == ButtonState.completed ? "" : "display: none;";
        CheckClass = state switch
        {
            ButtonState.failed => "oi oi-x",
            _ => "oi oi-check"
        };
    }

    private async Task CreateAndSendBundle(string FriendId)
    {
        // since we are sending a request we should create a key bundle for the other party to use to create a shared secret between us
        // when we accept a request we need to create a new bundle and send it to the other party, the other party generated their bundle when they sent the request

        // import our identity keys
        var keys = await bundleHandler.GetKeys(Id);

        if (keys.X509IdentityKey != null && keys.IdentityPrivateKey != null)
        {
            // generate a new bundle and save it to the server
            IKeyBundleModel bundle = encryptionClient.GenerateBundle(keys.X509IdentityKey, keys.IdentityPrivateKey);

            if (bundle is KeyBundleModel b)
            {
                // add OUR bundle to THIER bundles
                await bundleHandler.SetBundle(FriendId, Id, b);
            }

            // save the state of our encryption client so we can create a secret later when we get the other persons bundle should they want to be friends

            string clientState = encryptionClient.ExportState();

            if (await encryptionStateHandler.SetState(Id, FriendId, clientState))
            {
                logger.LogInformation("Saved State for encryption client");
            }
            else
            {
                logger.LogError("Failed to set encryption client state for {Id}", Id);
            }
        }
        else
        {
            logger.LogError("Failed to {MethodName} for {Id} no keys retrieved from bundle handler", nameof(CreateAndSendBundle), Id);
        }
    }

    private async Task Submit()
    {
        SearchTermValidationFailures?.Clear();

        var validation = searchValidator.Validate(displayName);

        if (validation.IsValid)
        {
            Task Wait()
            {
                return Task.Run(() => System.Threading.Thread.Sleep(500));
            }
            // update the button to show that we are working on changing the name
            UpdateButton("Searching", ButtonState.normal, true);

            string foundId = await displayNameHander.GetIdFromDisplayName(displayName.DisplayName);

            logger.LogInformation("Found Id {Id} for {FriendId}", foundId, displayName.DisplayName);

            if (foundId?.Length is null or 0)
            {
                // don't allow users to know that we instantly invalidated their request
                await Wait();
                UpdateButton("Not Found", ButtonState.failed, false);
                return;
            }

            // create and store our encryption budle so we can create a shared secret with that person
            await CreateAndSendBundle(foundId);

            await friendHandler.SendRequest(Id, foundId);

            // this is to make the user feel like the username has really been changed
            await Wait();

            // update the GUI to reflect the completed process
            UpdateButton("Request Sent", ButtonState.completed, false);
        }
        else
        {
            SearchTermValidationFailures = validation.Errors;
            return;
        }
    }
}
