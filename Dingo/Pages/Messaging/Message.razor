@page "/Message"

@inject ILogger<Message> logger
@using System.ComponentModel.DataAnnotations;
@using DingoDataAccess.Models.Friends
@using DingoAuthentication.Encryption

@inject IJSRuntime js

@inject IMessageHandler messageHandler
@inject IFriendHandler friendHandler

@inject IEncryptionClient<EncryptedDataModel> encryptionClient
@inject IEncryptedClientStateHandler clientStateHandler
@inject IKeyAndBundleHandler<KeyBundleModel> bundleHandler

@implements IDisposable

<h1 class="flex">
    Message @(Friend?.DisplayName ?? "Loading...")<span style="color:grey;">#@(Friend?.UniqueIdentifier ?? 0000)</span>
</h1>
<div @ref=ChatBox class="d-flex flex-column list-group-flush overflow-auto" style="height: 85vh;" id="exmaple">
    @foreach (var item in Messages)
    {
        <div class="list-group-item list-group-item-action shadow-sm my-2">
            <div class="d-flex">
                <img src=@(Friend.AvatarPath ?? "/Images/DefaultAvatar.png") class="rounded-circle flex my-auto" height="40" />
                <div class="mx-1 flex-fill">
                    <div>
                        <span class="fw-bold">@item.DisplayName</span><span style="color: grey;">#@item.UniqueIdentifier</span>
                    </div>
                    <div>
                        <span style="color: darkgray;">@item.TimeSent</span>
                        @if (item.ShowSpinner)
                        {
                            <div class="spinner-border spinner-border-sm text-success mx-1" role="status">
                                <span class="visually-hidden">Loading...</span>
                            </div>
                        }
                        @if (item.ShowCheck)
                        {
                            <span class="oi oi-circle-check mx-1" title="circle check" aria-hidden="true"></span>
                        }
                    </div>
                </div>
            </div>
            <div class="text-wrap">
                @item.Message
            </div>
        </div>
    }
</div>
<div class="flex">
    <EditForm Model="@InputValue" OnValidSubmit=@Submit>
        <div class="input-group mb-3">
            <InputText class="form-control" placeholder=@PlaceholderText aria-label="Message" @bind-Value=@InputValue.Value>

            </InputText>
            <!--
            <button class="btn btn-outline-secondary px-1" type="submit">
                <span class="oi oi-folder mx-1" title="Attach File" aria-hidden="true"></span>
            </button>
            <button class="btn btn-outline-secondary px-1" type="submit">
                <span class="oi oi-image mx-1" title="Attach Image" aria-hidden="true"></span>
            </button>
                -->
            <button class="btn btn-primary px-4" type="submit">
                <span class="oi oi-chat mx-1" title="Send Message" aria-hidden="true"></span>
            </button>
        </div>
    </EditForm>
</div>

@code {

    [CascadingParameter(Name = "MyFriendInfo")]
    protected IFriendModel MyFriendInfo { get; set; }

    [CascadingParameter(Name = "Id")]
    protected string Id { get; set; }

    [Parameter]
    public string FriendId { get; set; }

    public IFriendModel Friend { get; set; }

    List<IMessageModel> RawMessages = new();
    private List<MessageState> Messages = new();

    private ElementReference ChatBox;

    private string PlaceholderText => $"Message @ {Friend?.DisplayName ?? "Loading..."}#{Friend?.UniqueIdentifier ?? 0}";

    private FormModel InputValue = new();

    private bool BlockInput = false;

    private int RefreshPollingRate = 5_000;

    private System.Timers.Timer RefreshTimer = new();

    // ENCRYPTION METHODS

    private async Task LoadEncryptionClient()
    {
        // since we are chatting with this person we should already have a state stored to encrypt between us

        // get the encryption state for the person we are chatting with
        var state = await clientStateHandler.GetState(Id, FriendId);

        if (state != null)
        {
            encryptionClient.ImportState(state);
        }
        else
        {
            logger.LogError("Failed to get encryption state for {Id} for {FriendId}", Id, FriendId);
        }
    }

    private async Task SaveEncryptionState()
    {
        // export the local state to string
        string state = encryptionClient.ExportState();

        // ssave the string in the database
        await clientStateHandler.SetState(Id, FriendId, state);
    }

    private async Task SendMessage(string message)
    {
        // encrypt the message
        if (encryptionClient.TryEncrypt(message, out EncryptedDataModel encryptedData))
        {
            // serialize the message
            string serializedEncryptedData = Newtonsoft.Json.JsonConvert.SerializeObject(encryptedData);

            // send message over the wire

            MessageModel rawMessage = new()
            {
                SenderId = Id,
                Message = serializedEncryptedData,
                TimeSent = DateTime.UtcNow
            };

            await messageHandler.SendMessage(Id, FriendId, rawMessage);
        }
        else
        {
            logger.LogError("Failed to encrypt message for {Id} to {FriendId}", Id, FriendId);
        }
    }

    private void ReceiveMessage(IMessageModel rawMessage)
    {
        try
        {
            EncryptedDataModel deserializedEncryptedMessage = Newtonsoft.Json.JsonConvert.DeserializeObject<EncryptedDataModel>(rawMessage.Message);
            if (encryptionClient.TryDecrypt(deserializedEncryptedMessage, out string decryptedString))
            {
                Messages.Add(
                    new()
                    {
                        DisplayName = Friend.DisplayName,
                        ShowSpinner = false,
                        Message = decryptedString,
                        ShowCheck = false,
                        TimeSent = rawMessage.TimeSent,
                        UniqueIdentifier = Friend.UniqueIdentifier
                    }
                );
            }
        }
        catch (Exception e)
        {
            logger.LogError("Failed to receive message from {SenderId} Error: {Error}", rawMessage.SenderId, e);
        }
    }

    // END ENCRYPTION METHODS

    private async Task ScrollToBottomOfChatbox()
    {
        await js.InvokeVoidAsync("scrollToBottom", ChatBox);
    }

    private async Task Submit()
    {
        if (BlockInput)
        {
            return;
        }

        BlockInput = true;

        if (string.IsNullOrEmpty(InputValue.Value))
        {
            BlockInput = false;
            return;
        }

        await Dingo.Helpers.Sleep(100);

        // create a object to keep track of the object and update the spinners as necessary
        var msgReference = new MessageState()
        {
            DisplayName = MyFriendInfo.DisplayName,
            ShowSpinner = true,
            Message = InputValue.Value,
            ShowCheck = false,
            TimeSent = DateTime.UtcNow,
            UniqueIdentifier = MyFriendInfo.UniqueIdentifier
        };

        Messages.Add(msgReference);

        // show animation immediately even though we haven't sent the message yet
        await ScrollToBottomOfChatbox();

        await SendMessage(InputValue.Value);

        // update the spinners
        msgReference.ShowCheck = true;
        msgReference.ShowSpinner = false;

        logger.LogInformation("Message {Message}", InputValue.Value);

        InputValue.Value = "";

        BlockInput = false;
    }

    protected override async Task OnInitializedAsync()
    {
        await base.OnInitializedAsync();

        logger.LogInformation("Initialized Component {ComponentName} Params: {Param1}:{Param1Value} {Param2}:{Param2Value}", nameof(Message), nameof(Id), Id, nameof(MyFriendInfo), MyFriendInfo);

        await LoadMessages();

        RefreshTimer.Interval = RefreshPollingRate;
        RefreshTimer.Elapsed += async (x, y) => await LoadMessages();
        RefreshTimer.AutoReset = true;
        RefreshTimer.Start();
    }

    private async Task LoadMessages()
    {
        // this retrieves the messages for the person we are messaging, this also permenantly deletes those messages from the database, once the messages leave memory they are gone forever
        RawMessages = await messageHandler.GetMessages(Id, FriendId);

        await RedrawMessages();

        await ScrollToBottomOfChatbox();
    }

    private async Task RedrawMessages()
    {
        // make sure we have the friend model for this friend
        Friend ??= await friendHandler.GetFriend(FriendId);

        if (Friend is null)
        {
            return;
        }

        // draw the messages
        foreach (var item in RawMessages)
        {
            ReceiveMessage(item);
        }

        RawMessages.Clear();

        await InvokeAsync(() => StateHasChanged());
    }

    private class FormModel
    {
        public string Value { get; set; }
    }

    private class MessageState
    {
        public string DisplayName { get; set; }
        public short UniqueIdentifier { get; set; }
        public string Message { get; set; }
        public bool ShowSpinner { get; set; } = false;
        public bool ShowCheck { get; set; } = false;
        public DateTime TimeSent { get; set; }
    }

    public void Dispose()
    {
        RefreshTimer?.Stop();
        RefreshTimer?.Close();
        RefreshTimer?.Dispose();
    }
}
